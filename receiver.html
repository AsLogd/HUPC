<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Cardboard Example</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #example {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
    </style>
    <script src="/socket.io/socket.io.js"></script>
  </head>
  <body>
    <div id="example"></div>

  <script src="js/third-party/threejs/three.js"></script>
  <script src="js/third-party/threejs/StereoEffect.js"></script>
  <script src="js/third-party/threejs/DeviceOrientationControls.js"></script>
  <script src="js/third-party/threejs/OrbitControls.js"></script>
  <script src="js/physi.js"></script>
    <script src="/fonts/optimer_regular.typeface.js"></script>

  <script>
    var camera, scene, renderer;
    var effect, controls;
    var element, container;

    var clock = new THREE.Clock();
    var gyro = {x:0,y:0,z:0,w:0};

    var player;
    var playerSpeed = 1000;
    var playerVector = {x:0,y:0};
    var raycastableObjects = [];

    init();
    animate();

function createText(text, x, y, z) {

        textGeo = new THREE.TextGeometry( text, {

          font: 'optimer',

          size: 10,
          height: 5

        });

        textGeo.computeBoundingBox();
        textGeo.computeVertexNormals();  

        var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

        var material = new THREE.MeshPhongMaterial({color: 0xFFFFFF});
        textMesh1 = new THREE.Mesh( textGeo, material );

        textMesh1.position.x = x;
        textMesh1.position.y = y;
        textMesh1.position.z = z;

        textMesh1.rotation.x = 0;
        textMesh1.rotation.y = -90;

        scene.add( textMesh1 );


      }

    function computeQuaternionFromEulers(alpha, beta, gamma){
      var degtorad = Math.PI / 180;
      var _x = beta * degtorad ; // beta value
      var _y = gamma * degtorad ; // gamma value
      var _z = alpha * degtorad ; // alpha value

      var cX = Math.cos( _x/2 );
      var cY = Math.cos( _y/2 );
      var cZ = Math.cos( _z/2 );
      var sX = Math.sin( _x/2 );
      var sY = Math.sin( _y/2 );
      var sZ = Math.sin( _z/2 );

      //
      // ZXY quaternion construction.
      //

      var w = cX * cY * cZ - sX * sY * sZ;
      var x = sX * cY * cZ - cX * sY * sZ;
      var y = cX * sY * cZ + sX * cY * sZ;
      var z = cX * cY * sZ + sX * sY * cZ;

      //return [ w, x, y, z ];
      return {"x":x,"y":y,"z":z,"w":w};//return a simple object with the four quaternion values
    }

    function computeOrientationQuaternion(){
      var quaternion = gyro;
      var invertedQ=inverseQuaternion(quaternion);
      return invertedQ;

    }

    function inverseQuaternion(q)
    {
      return {"x":q.x,"y":q.y,"z":q.z,"w": -q.w};
    }

    function init() {

      var targetCube = new THREE.Mesh(new THREE.CubeGeometry(4, 4, 4), new THREE.MeshNormalMaterial());
      var socket = io();
      
      socket.on("rotation", function(rotation){
      
        gyro = computeQuaternionFromEulers(rotation.alpha, rotation.beta, rotation.gamma);
        var q = computeOrientationQuaternion();
        var quot = new THREE.Quaternion();
        quot.set(q.x,q.y,q.z,q.w);

        targetCube.setRotationFromQuaternion(quot);
        targetCube.rotation.y += camera.rotation.y;

      });

      socket.on("move", function(moveVector){
        playerVector = moveVector;
      });

      Physijs.scripts.worker = '/js/physijs_worker.js';
      Physijs.scripts.ammo = '/js/ammo.js';

      renderer = new THREE.WebGLRenderer({ antialias: true });
      element = renderer.domElement;
      container = document.getElementById('example');
      container.appendChild(element);

      effect = new THREE.StereoEffect(renderer);

      scene = new Physijs.Scene;

      camera = new THREE.PerspectiveCamera(90, 1, 0.001, 700);
      camera.position.set(0, 10, 0);
      scene.add(camera);

      controls = new THREE.OrbitControls(camera, element);
      controls.rotateUp(Math.PI / 4);
      controls.target.set(
        camera.position.x + 0.1,
        camera.position.y,
        camera.position.z
      );
      controls.noZoom = true;
      controls.noPan = true;

      function setOrientationControls(e) {
        if (!e.alpha) {
          return;
        }

        controls = new THREE.DeviceOrientationControls(camera, true);
        controls.connect();
        controls.update();

        element.addEventListener('click', fullscreen, false);

        window.removeEventListener('deviceorientation', setOrientationControls, true);
      }
      window.addEventListener('deviceorientation', setOrientationControls, true);


      var light = new THREE.HemisphereLight(0x777777, 0x000000, 0.6);
      scene.add(light);

      var texture = THREE.ImageUtils.loadTexture(
        'textures/patterns/checker.png'
      );
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat = new THREE.Vector2(50, 50);
      texture.anisotropy = renderer.getMaxAnisotropy();

      var material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        specular: 0xffffff,
        shininess: 20,
        shading: THREE.FlatShading,
        map: texture
      });

var ground = new Physijs.PlaneMesh(
            new THREE.PlaneGeometry( 1000, 1000 ),
            material,
            0
        );
ground.rotation.x = -Math.PI / 2;
scene.add( ground );
/*
      var geometry = new THREE.PlaneGeometry(1000, 1000);


      var mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI / 2;
      scene.add(mesh);
*/
      ////ROTATIONAL CUBE
      scene.add(targetCube);
      camera.add(targetCube);
      //targetCube.rotation.reorder('YXZ');
      targetCube.position.z = -12;
      targetCube.position.x = 1;
      targetCube.position.y = -1;
      ////---ROTATIONAL CUBE

      ///TEST PHYSICS CUBE
      // Box

        var box = new Physijs.BoxMesh(
            new THREE.CubeGeometry( 2, 2, 2 ),
            new THREE.MeshBasicMaterial({ color: 0x888888 })
        );
        box.position.set(20, 10, 0);
        scene.add( box );
        raycastableObjects.push(box);
      //PLAYER

      var playermaterial = Physijs.createMaterial(
      new THREE.Material({ transparent:true }),
      5,
      0.2
      );

        player = new Physijs.CylinderMesh(
            new THREE.CylinderGeometry(  5, 5, 5, 32  ),
           playermaterial
        );
        player.rotation.y = 90;
        player.position.set(0, 20, 0);
        scene.add( player );
        player.add(camera);
        player.setAngularFactor(new THREE.Vector3(0,0,0));



      window.addEventListener('resize', resize, false);
      setTimeout(resize, 1);
    }

    function resize() {
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
      effect.setSize(width, height);
    }

    function update(dt) {
      resize();

      camera.updateProjectionMatrix();
      
      controls.update(dt);
    }

    function render(dt) {
      effect.render(scene, camera);
    }

    function animate(t) {
      requestAnimationFrame(animate);

      //Player movement
      var vectorOK = new THREE.Vector3(playerVector.x, 0, playerVector.y);
      vectorOK.multiplyScalar(playerSpeed);
      vectorOK.multiplyScalar(clock.getDelta());
      vectorOK.y = (player.getLinearVelocity()).y;
      player.setLinearVelocity(vectorOK);



      scene.simulate(); // run physics
      update(clock.getDelta());
      render(clock.getDelta());
    }

    function fullscreen() {
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      } else if (container.mozRequestFullScreen) {
        container.mozRequestFullScreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      }
    }
  </script>
  </body>
</html>


